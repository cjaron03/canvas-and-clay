# Flask Application Configuration
# ==============================

# Secret key for session management and CSRF protection
# Generate a secure random key for production: python -c "import secrets; print(secrets.token_hex(32))"
SECRET_KEY=dev-secret-key-change-in-production

# PII Encryption Configuration
# ============================
#
# CRITICAL FOR MULTI-MACHINE DEPLOYMENTS:
# The PII_ENCRYPTION_KEY encrypts sensitive data (emails) in the database.
# If you deploy to multiple machines and want to sync users between them,
# you MUST use the same key on all machines.
#
# KEY REQUIREMENTS:
# - Minimum 16 characters (longer is better)
# - Use a randomly generated key (NOT a common password)
# - Keys are processed through Argon2id for memory-hard key derivation
#
# SETUP INSTRUCTIONS:
# 1. Generate a secure key (do this ONCE, save it securely):
#    python3 -c "import secrets; print(secrets.token_urlsafe(32))"
#
# 2. Use the SAME key across all deployments that need to:
#    - Read existing encrypted user data
#    - Import users from another deployment
#    - Share the same database backup
#
# 3. Store the key securely:
#    - Production: Use a secrets manager (AWS Secrets Manager, HashiCorp Vault)
#    - Team development: Use a shared password manager (1Password, Bitwarden)
#    - NEVER commit to version control
#
# KEY ROTATION:
# If you need to change the key, first export users, then import with new key:
#    python3 export_users.py --output users_backup.json
#    # Update PII_ENCRYPTION_KEY to new value
#    python3 import_users.py --input users_backup.json --keep-passwords
#
# WARNING: If you lose this key, encrypted emails CANNOT be recovered!
# WARNING: Different keys = users cannot log in until you export/import
#
# If not set, falls back to SECRET_KEY (not recommended - use separate key)
# In development mode (FLASK_ENV=development), an ephemeral key is used if neither is set
# WARNING: Ephemeral keys cause data loss on restart - only use for local development
#
# ERRORS:
# ERR_KEY_002 - Key is too short (need at least 16 chars)
# ERR_KEY_003 - Key matches a commonly used weak password
#
PII_ENCRYPTION_KEY=your-32-byte-encryption-key-here

# Flask environment (development, production, testing)
FLASK_ENV=development

# Enable Flask debug mode (true/false)
FLASK_DEBUG=false

# Session Security
# ===============

# Allow cookies over HTTP for local development (set to false in production)
# When false, cookies require HTTPS (Secure flag enabled)
ALLOW_INSECURE_COOKIES=true

# CORS Configuration
# ==================

# Comma-separated list of allowed origins for CORS
# Example: http://localhost:5173,https://example.com
CORS_ORIGINS=http://localhost:5173

# Database Configuration
# =====================

# Option 1: Use a single DATABASE_URL (recommended)
# Format: postgresql://user:password@host:port/database
# DATABASE_URL=postgresql://canvas_db:clay123@localhost:5432/canvas_clay

# Option 2: Use granular database settings
DB_HOST=db
DB_PORT=5432
DB_NAME=canvas_clay
DB_USER=canvas_db
# SECURITY: Generate a strong password for production:
#   openssl rand -base64 32
DB_PASSWORD=REPLACE_WITH_STRONG_PASSWORD
DB_ENGINE=postgresql

# Database Connection Pooling (optional)
DB_POOL_SIZE=5
DB_POOL_MAX_OVERFLOW=10
DB_POOL_TIMEOUT=30
DB_POOL_RECYCLE=1800
DB_POOL_PRE_PING=true

# Database SSL Configuration (optional, for production)
# DB_SSL_MODE=require
# DB_SSL_ROOT_CERT=/path/to/ca-certificate.crt

# Test Database Configuration (optional)
# Used when running pytest
TEST_DATABASE_URL=sqlite:///app_test.db
PYTEST_DATABASE_URL=sqlite:///app_test.db

# Bootstrap Admin Account
# =======================

# Email for the initial admin account (created on first run if user doesn't exist)
BOOTSTRAP_ADMIN_EMAIL=admin@canvas-clay.local

# Password for the initial admin account (must meet password requirements)
BOOTSTRAP_ADMIN_PASSWORD=ChangeMe123

# Password Reset Configuration
# ============================

# Time-to-live for password reset codes in minutes (default: 15)
PASSWORD_RESET_CODE_TTL_MINUTES=15

# Maximum length for password reset request messages (default: 500)
PASSWORD_RESET_MESSAGE_MAX_LENGTH=500

# Content Security Policy (optional)
# ===================================

# Custom CSP policy (leave unset to use defaults)
# CSP_POLICY=default-src 'self'; script-src 'self' 'unsafe-inline'

# Backup Encryption Configuration
# ================================
#
# Optional: Set a master key for encrypting backup archives.
# When configured, backups can be encrypted using this key instead of
# per-backup passphrases. This is useful for automated backup systems.
#
# SETUP INSTRUCTIONS:
# 1. Generate a secure key (do this ONCE, save it securely):
#    python3 -c "import secrets; print(secrets.token_urlsafe(32))"
#
# 2. Store the key SEPARATELY from your backups:
#    - Use a secrets manager (AWS Secrets Manager, HashiCorp Vault)
#    - Store in a secure password manager
#    - Keep a physical backup in a safe location
#
# USAGE:
# - API: Set use_env_key: true in backup/restore requests
# - CLI: Use --use-env-key flag with backup.py/restore.py
#
# WARNING: If you lose this key, encrypted backups CANNOT be recovered!
# WARNING: Keep the key separate from the backups (different storage location)
#
# Leave unset to require per-backup passphrases instead
# BACKUP_ENCRYPTION_KEY=your-backup-encryption-key-here

# Setup Wizard Configuration
# ==========================

# Auto-seed demo data on first run when database is empty
# Set to 1 to automatically create demo users, artists, and artworks
# Useful for quick development setup; disable (0) for production deployments
AUTO_SEED_DEMO=0
