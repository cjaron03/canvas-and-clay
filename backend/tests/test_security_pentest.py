"""
Penetration Testing Suite for Canvas & Clay
============================================
Security tests organized by severity level.
Run with: pytest tests/test_security_pentest.py -v
Run critical only: pytest tests/test_security_pentest.py -m critical -v
"""
import io
import time
import statistics
from datetime import datetime, timezone

import pytest
from PIL import Image

from app import app, db, User, Artist, Artwork, Storage, ArtworkPhoto, limiter
from conftest import find_user_by_email


# =============================================================================
# FIXTURES
# =============================================================================

@pytest.fixture
def client():
    """Test client with security-focused configuration."""
    app.config['TESTING'] = True
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {}
    app.config['WTF_CSRF_ENABLED'] = False
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['RATELIMIT_ENABLED'] = False

    limiter.enabled = False

    with app.test_client(use_cookies=True) as test_client:
        with app.app_context():
            db.create_all()
            yield test_client
            db.session.remove()
            db.drop_all()


@pytest.fixture
def csrf_client():
    """Client with CSRF protection enabled."""
    app.config['TESTING'] = True
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {}
    app.config['WTF_CSRF_ENABLED'] = True
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['RATELIMIT_ENABLED'] = False

    limiter.enabled = False

    with app.test_client(use_cookies=True) as test_client:
        with app.app_context():
            db.create_all()
            yield test_client
            db.session.remove()
            db.drop_all()


def _get_csrf_token(client):
    response = client.get('/auth/csrf-token')
    return response.get_json()['csrf_token']


def _register_user(client, email, password):
    return client.post('/auth/register', json={'email': email, 'password': password})


def _login_user(client, email, password):
    return client.post('/auth/login', json={'email': email, 'password': password})


def _make_image(width=100, height=100, color='blue', format='JPEG'):
    """Create test image in memory."""
    img = Image.new('RGB', (width, height), color=color)
    buffer = io.BytesIO()
    img.save(buffer, format=format)
    buffer.seek(0)
    return buffer


# =============================================================================
# CRITICAL SEVERITY TESTS - Full compromise vectors
# =============================================================================

@pytest.mark.critical
class TestCriticalVulnerabilities:
    """Tests for vulnerabilities that could lead to full system compromise."""

    def test_sql_injection_login_email(self, client):
        """Ensure SQL injection payloads in email field are blocked."""
        payloads = [
            "' OR '1'='1",
            "admin'--",
            "' OR '1'='1' --",
            "' UNION SELECT NULL,NULL,NULL--",
            "'; DROP TABLE users; --",
            "admin' OR '1'='1' /*",
        ]

        for payload in payloads:
            response = client.post('/auth/login', json={
                'email': payload,
                'password': 'anything'
            })
            # Should return 400/401, never 200 with data
            assert response.status_code in [400, 401], f"SQLi payload not blocked: {payload}"
            if response.status_code == 200:
                data = response.get_json()
                assert 'user' not in data or data.get('user') is None

    def test_sql_injection_login_password(self, client):
        """Ensure SQL injection in password field is blocked."""
        _register_user(client, 'sqli@test.com', 'ValidPass123!')

        payloads = [
            "' OR '1'='1",
            "anything' OR '1'='1'--",
        ]

        for payload in payloads:
            response = client.post('/auth/login', json={
                'email': 'sqli@test.com',
                'password': payload
            })
            assert response.status_code == 401, f"SQLi in password not blocked: {payload}"

    def test_rce_via_polyglot_upload(self, client):
        """Ensure polyglot files with embedded code are sanitized."""
        # Register and login as admin
        _register_user(client, 'rce@test.com', 'RCEPass123!')
        _login_user(client, 'rce@test.com', 'RCEPass123!')

        user = find_user_by_email(User, 'rce@test.com')
        user.role = 'admin'
        db.session.commit()

        # Create storage and artwork
        storage = Storage(storage_id='SRCE001', storage_loc='RCE Test', storage_type='rack')
        artist = Artist(artist_id='ARCE0001', artist_fname='RCE', artist_lname='Test',
                       artist_email='rce.artist@test.com')
        db.session.add_all([storage, artist])
        db.session.flush()

        artwork = Artwork(artwork_num='AWRCE001', artwork_ttl='RCE Test',
                         artwork_medium='Digital', storage_id='SRCE001', artist_id='ARCE0001')
        db.session.add(artwork)
        db.session.commit()

        # Valid JPEG header + PHP code (polyglot)
        polyglot = (
            b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00'
            + b'\x00' * 100
            + b'<?php system($_GET["cmd"]); ?>'
            + b'\xff\xd9'
        )

        response = client.post(
            f'/api/artworks/AWRCE001/photos',
            data={'photo': (io.BytesIO(polyglot), 'polyglot.jpg')},
            content_type='multipart/form-data'
        )

        # Should either reject or sanitize the file
        if response.status_code == 201:
            # If accepted, verify no PHP code in stored file
            photo = response.get_json().get('photo', {})
            assert 'php' not in photo.get('filename', '').lower()

    def test_command_injection_search(self, client):
        """Ensure command injection attempts in search are blocked."""
        _register_user(client, 'cmdi@test.com', 'CmdPass123!')
        _login_user(client, 'cmdi@test.com', 'CmdPass123!')

        payloads = [
            "$(whoami)",
            "`id`",
            "; ls -la",
            "| cat /etc/passwd",
            "&& rm -rf /",
        ]

        for payload in payloads:
            # Use the artworks suggest endpoint for search testing
            response = client.get(f'/api/artworks/suggest?q={payload}')
            # Should return normally without executing commands
            assert response.status_code in [200, 400, 404]
            if response.status_code == 200:
                data = response.get_json()
                assert 'root:' not in str(data)
                assert 'uid=' not in str(data)


# =============================================================================
# HIGH SEVERITY TESTS - Data exposure vectors
# =============================================================================

@pytest.mark.high
class TestHighSeverityVulnerabilities:
    """Tests for vulnerabilities that could lead to data exposure."""

    def test_csrf_token_reuse_across_sessions(self, csrf_client):
        """CSRF tokens from one session should not work in another."""
        # Session 1: Get token
        token1 = _get_csrf_token(csrf_client)

        # Create a fresh client (simulates different browser/session)
        with app.test_client(use_cookies=True) as new_client:
            # Session 2: Try to use Session 1's token in a different session
            response = new_client.post(
                '/auth/register',
                json={'email': 'csrf_reuse@test.com', 'password': 'CsrfPass123!'},
                headers={'X-CSRFToken': token1}
            )

            # Token from different session should be rejected
            assert response.status_code == 400

    def test_session_fixation(self, client):
        """Session ID should change after login."""
        # Get pre-login session cookie
        response = client.get('/auth/csrf-token')
        pre_session = response.headers.get('Set-Cookie', '')

        # Register and login
        _register_user(client, 'fixation@test.com', 'FixPass123!')
        login_response = _login_user(client, 'fixation@test.com', 'FixPass123!')

        # Get post-login session from Set-Cookie header
        post_session = login_response.headers.get('Set-Cookie', '')

        # If session cookies are present, they should be different
        # This validates that session is regenerated after login
        if 'session=' in pre_session and 'session=' in post_session:
            # Extract session values
            import re
            pre_match = re.search(r'session=([^;]+)', pre_session)
            post_match = re.search(r'session=([^;]+)', post_session)
            if pre_match and post_match:
                assert pre_match.group(1) != post_match.group(1), \
                    "Session fixation: session ID unchanged after login"

    def test_horizontal_privilege_escalation(self, client):
        """User A should not access User B's resources."""
        # Create User A with artwork
        _register_user(client, 'user_a@test.com', 'UserAPass123!')
        _login_user(client, 'user_a@test.com', 'UserAPass123!')
        user_a = find_user_by_email(User, 'user_a@test.com')

        storage = Storage(storage_id='SHPE001', storage_loc='HPE Test', storage_type='rack')
        artist = Artist(artist_id='AHPE0001', artist_fname='HPE', artist_lname='Test',
                       artist_email='hpe.artist@test.com', user_id=user_a.id)
        db.session.add_all([storage, artist])
        db.session.flush()

        artwork = Artwork(artwork_num='AWHPE001', artwork_ttl='User A Artwork',
                         artwork_medium='Oil', storage_id='SHPE001', artist_id='AHPE0001')
        db.session.add(artwork)
        db.session.commit()

        # Logout User A
        client.post('/auth/logout')

        # Login as User B
        _register_user(client, 'user_b@test.com', 'UserBPass123!')
        _login_user(client, 'user_b@test.com', 'UserBPass123!')

        # User B tries to upload to User A's artwork
        image = _make_image()
        response = client.post(
            '/api/artworks/AWHPE001/photos',
            data={'photo': (image, 'attack.jpg')},
            content_type='multipart/form-data'
        )

        assert response.status_code == 403

    def test_vertical_privilege_escalation(self, client):
        """Guest user should not access admin endpoints."""
        _register_user(client, 'guest@test.com', 'GuestPass123!')
        _login_user(client, 'guest@test.com', 'GuestPass123!')

        admin_endpoints = [
            ('/api/admin/console/stats', 'GET', None),
            ('/api/admin/console/health', 'GET', None),
            ('/api/admin/console/audit-log', 'GET', None),
            ('/api/admin/bulk-upload', 'POST', {}),
        ]

        for endpoint, method, data in admin_endpoints:
            if method == 'GET':
                response = client.get(endpoint)
            else:
                response = client.post(endpoint, json=data)

            assert response.status_code in [401, 403], \
                f"Admin endpoint {endpoint} accessible to guest"


# =============================================================================
# MEDIUM SEVERITY TESTS - Reconnaissance vectors
# =============================================================================

@pytest.mark.medium
class TestMediumSeverityVulnerabilities:
    """Tests for vulnerabilities that enable reconnaissance."""

    def test_user_enumeration_via_timing(self, client):
        """Check if timing differences reveal valid users."""
        # Create a known user
        _register_user(client, 'timing_user@test.com', 'TimingPass123!')

        # Measure timing for valid user (wrong password)
        valid_times = []
        for _ in range(10):
            start = time.perf_counter()
            client.post('/auth/login', json={
                'email': 'timing_user@test.com',
                'password': 'wrongpassword'
            })
            valid_times.append(time.perf_counter() - start)

        # Measure timing for invalid user
        invalid_times = []
        for _ in range(10):
            start = time.perf_counter()
            client.post('/auth/login', json={
                'email': 'nonexistent_user@test.com',
                'password': 'wrongpassword'
            })
            invalid_times.append(time.perf_counter() - start)

        avg_valid = statistics.mean(valid_times)
        avg_invalid = statistics.mean(invalid_times)
        diff_ms = abs(avg_valid - avg_invalid) * 1000

        # Difference should be minimal if using constant-time comparison
        # Using 200ms threshold to account for CI environment variance
        # (bcrypt provides constant-time behavior, but CI has inconsistent timing)
        assert diff_ms < 200, f"Timing difference {diff_ms:.2f}ms may enable enumeration"

    def test_user_enumeration_via_registration(self, client):
        """Registration should not reveal if email already exists."""
        _register_user(client, 'exists@test.com', 'ExistsPass123!')

        # Try to register same email
        response = client.post('/auth/register', json={
            'email': 'exists@test.com',
            'password': 'DifferentPass123!'
        })

        # Should not explicitly say "email already exists"
        if response.status_code == 400:
            msg = response.get_json().get('error', '').lower()
            assert 'already exists' not in msg or 'already registered' not in msg

    def test_fuzz_cli_parser(self, client):
        """Fuzz the CLI parser with malformed input."""
        _register_user(client, 'fuzz@test.com', 'FuzzPass123!')
        _login_user(client, 'fuzz@test.com', 'FuzzPass123!')

        user = find_user_by_email(User, 'fuzz@test.com')
        user.role = 'admin'
        db.session.commit()

        fuzz_inputs = [
            "",  # Empty
            "a" * 10000,  # Very long
            "\x00\x00\x00",  # Null bytes
            "create artist " + "A" * 1000,  # Long entity ID
            "show artwork \n\n\nAW123456",  # Newlines
            "delete ' OR '1'='1",  # SQL injection attempt
            "update $(whoami)",  # Command injection
            '"""""""""""',  # Quote hell
            "\r\n\r\n",  # CRLF injection
            "list\tartists",  # Tab characters
            "create artist\x00hidden",  # Null byte injection
        ]

        for fuzz_input in fuzz_inputs:
            try:
                response = client.post('/api/admin/console/cli', json={
                    'command': fuzz_input,
                    'write_mode': False
                })
                # Should fail gracefully, not crash or expose internals
                assert response.status_code in [200, 400, 401, 403, 422]
                if response.status_code == 200:
                    data = response.get_json()
                    # Should not contain stack traces
                    output = str(data.get('output', ''))
                    assert 'Traceback' not in output
                    assert 'File "' not in output
            except Exception as e:
                pytest.fail(f"CLI crashed on fuzz input: {repr(fuzz_input)}: {e}")

    def test_path_traversal_filename(self, client):
        """Uploaded filenames should not allow path traversal."""
        _register_user(client, 'traversal@test.com', 'TraversalPass123!')
        _login_user(client, 'traversal@test.com', 'TraversalPass123!')

        user = find_user_by_email(User, 'traversal@test.com')
        user.role = 'admin'
        db.session.commit()

        storage = Storage(storage_id='STRAV01', storage_loc='Traversal', storage_type='rack')
        artist = Artist(artist_id='ATRAV001', artist_fname='Trav', artist_lname='Test',
                       artist_email='trav@test.com')
        db.session.add_all([storage, artist])
        db.session.flush()

        artwork = Artwork(artwork_num='AWTRAV01', artwork_ttl='Traversal Test',
                         artwork_medium='Oil', storage_id='STRAV01', artist_id='ATRAV001')
        db.session.add(artwork)
        db.session.commit()

        traversal_names = [
            '../../../etc/passwd.jpg',
            '..\\..\\..\\windows\\win.ini.jpg',
            '....//....//....//etc/passwd.jpg',
            'test\x00.php.jpg',  # Null byte
        ]

        for name in traversal_names:
            image = _make_image()
            response = client.post(
                '/api/artworks/AWTRAV01/photos',
                data={'photo': (image, name)},
                content_type='multipart/form-data'
            )

            if response.status_code == 201:
                photo = response.get_json().get('photo', {})
                filename = photo.get('filename', '')
                assert '..' not in filename
                assert '/' not in filename
                assert '\\' not in filename
                assert '\x00' not in filename


# =============================================================================
# LOW SEVERITY TESTS - Information disclosure
# =============================================================================

@pytest.mark.low
class TestLowSeverityVulnerabilities:
    """Tests for information disclosure and minor issues."""

    def test_verbose_error_messages(self, client):
        """Error responses should not leak internal details."""
        responses = [
            client.get('/api/nonexistent'),
            client.post('/auth/login', json={}),
            client.post('/auth/login', json={'email': 'x', 'password': 'y'}),
        ]

        for response in responses:
            text = response.get_data(as_text=True).lower()
            # Should not contain stack traces or internal paths
            assert 'traceback' not in text
            assert 'file "/' not in text
            assert '/usr/local' not in text
            assert 'site-packages' not in text

    def test_security_headers_present(self, client):
        """Response should include security headers."""
        response = client.get('/')

        # Note: These may be set by reverse proxy in production
        # This test documents expected headers
        headers_to_check = {
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
        }

        for header, expected in headers_to_check.items():
            value = response.headers.get(header)
            if value:
                if isinstance(expected, list):
                    assert value in expected
                else:
                    assert value == expected

    def test_session_cookie_flags(self, client):
        """Session cookies should have security flags."""
        _register_user(client, 'cookie@test.com', 'CookiePass123!')
        response = _login_user(client, 'cookie@test.com', 'CookiePass123!')

        # Check Set-Cookie header for security flags
        set_cookie = response.headers.get('Set-Cookie', '')

        # In test mode, Secure flag is disabled (no HTTPS)
        # HttpOnly should always be present for session cookies
        if 'session=' in set_cookie:
            # HttpOnly flag should be set
            assert 'HttpOnly' in set_cookie, "Session cookie missing HttpOnly flag"
            # SameSite should be set
            assert 'SameSite' in set_cookie or 'samesite' in set_cookie.lower(), \
                "Session cookie missing SameSite attribute"

    def test_no_sensitive_data_in_logs(self, client):
        """Passwords should not appear in response bodies."""
        password = 'SuperSecret123!'
        response = _register_user(client, 'nolog@test.com', password)

        response_text = response.get_data(as_text=True)
        assert password not in response_text

        response = _login_user(client, 'nolog@test.com', password)
        response_text = response.get_data(as_text=True)
        assert password not in response_text
